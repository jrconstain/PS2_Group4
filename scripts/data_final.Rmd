---
title: "data_preparation"
author: "G4"
date: "2025-10-16"
output: html_document
---

# Set-up

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(pacman)

p_load(rio, # Import/export data.
       tidyverse, # Tidy-data.
       stargazer, # Descriptive statistics.
       gt, # Descriptive statistics.
       gtsummary,
       caret, # For predictive model assessment.
       gridExtra, # Arrange plots.
       skimr, # Summarize data.
       here, #for file searching
       readr, #for opening files
       ggplot2,
       boot,
       scales,
       car,
       dplyr,
       tidyr,
       stringr
       )
```

# Load Data

```{r}
# Load all 4 data archives

ruta1 <- here("stores", "train_hogares.csv")
df_train_hogares <- read_csv(ruta1)

ruta2 <- here("stores", "train_personas.csv")
df_train_personas <- read_csv(ruta2)

ruta3 <- here("stores", "test_personas.csv")
df_test_personas <- read_csv(ruta3)

ruta4 <- here("stores", "test_hogares.csv")
df_test_hogares <- read_csv(ruta4)

```

# Create new variables at individual level

```{r}
# Function to create years of education
add_edu_years <- function(df) {
  df$edu_years <- ifelse(
    df$P6210 %in% c(1, 2, 9), 0, # None, Preschool, Unknown → 0
    ifelse(
      df$P6210 %in% c(3, 4, 5), df$P6210s1, # Primary or Secondary → as is
      ifelse(df$P6210 == 6, df$P6210s1 + 11, NA_real_) # Tertiary → add 11
    )
  )
  df
}


# Function to create years of experience (Mincer-style proxy)
# exp = age - edu_years - 6
add_experience <- function(df) {
  df$exp <- df$P6040 - df$edu_years - 6
  df
}

# Function to Manage NA's on labor indicators
fill_labor_nas <- function(df) {
  vars <- c("Pet", "Oc", "Des", "Ina")
  df %>%
    mutate(across(all_of(vars), ~ as.integer(replace(., is.na(.), 0L))))
}

# Define PET_flexible (Urbano: 15–64 años; Rural: 12–69 años)
add_pet_flexible <- function(df) {
  df$PET_flexible <- ifelse(
    is.na(df$P6040), NA_integer_,
    ifelse(
      df$Clase == 1,                           # Urbano
      ifelse(df$P6040 >= 15 & df$P6040 <= 64, 1L, 0L),
      ifelse(df$P6040 >= 12 & df$P6040 <= 69, 1L, 0L) # Rural
    )
  )
  df
}


# Apply functiona to Train and Test
df_train_personas <- add_edu_years(df_train_personas)
df_test_personas  <- add_edu_years(df_test_personas)

df_train_personas <- add_experience(df_train_personas)
df_test_personas  <- add_experience(df_test_personas)

df_train_personas <- fill_labor_nas(df_train_personas)
df_test_personas  <- fill_labor_nas(df_test_personas)

df_train_personas <- add_pet_flexible(df_train_personas)
df_test_personas  <- add_pet_flexible(df_test_personas)

```


# Agreggate variables to household level

```{r}
agg_personas_to_hogares_plus_2 <- function(df_personas) {

  # Helpers para robustez numérica
  safe_div <- function(a, b) ifelse(is.na(b) | b <= 0, 0, a / b)

  df_personas %>%
    group_by(id) %>%
    summarise(
      # ===== BASE DE CONTEOS ===================================================
      n_personas = n(),
      n_occ      = sum(Oc  == 1, na.rm = TRUE),
      n_des      = sum(Des == 1, na.rm = TRUE),
      n_ina      = sum(Ina == 1, na.rm = TRUE),
      n_pet      = sum(Pet == 1, na.rm = TRUE),

      # ===== PET flexible ===
      n_pet_flex        = sum(PET_flexible == 1, na.rm = TRUE),
      n_no_pet_flex     = n_personas - n_pet_flex,
      n_occ_in_pet_flex = sum(Oc == 1 & PET_flexible == 1, na.rm = TRUE),
      

      # ===== COMPOSICIÓN / PROPORCIONES (LEGADO + NUEVAS) =====================
      prop_occ_nper     = safe_div(n_occ, n_personas),
      prop_des_nper     = safe_div(n_des, n_personas),         # NUEVA
      prop_ina_nper     = safe_div(n_ina, n_personas),         # NUEVA
      prop_no_pet_nper  = safe_div(n_no_pet_flex, n_personas), # NUEVA (PET flexible)
      prop_occ_pet      = safe_div(n_occ, n_pet),              # LEGADO (PET original)
      prop_occ_pet_flex = safe_div(n_occ_in_pet_flex, n_pet_flex), # NUEVA (PET flexible)

      # ===== JEFE DEL HOGAR: CARACTERÍSTICAS ==================================
      edad_jefe       = dplyr::first(P6040[P6050 == 1]),
      sexo_jefe       = dplyr::first(P6020[P6050 == 1]),
      tam_emp_jefe    = dplyr::coalesce(dplyr::first(P6870[P6050 == 1]), 0),
      cotiza_pens_jefe= dplyr::coalesce(dplyr::first(P6920[P6050 == 1]), 0),
      pos_ocup_jefe   = dplyr::coalesce(dplyr::first(P6430[P6050 == 1]), 0),
      antig_jefe      = dplyr::coalesce(dplyr::first(P6426[P6050 == 1]), 0), # si NA -> 0
      jefe_max_edu    = max(P6210[P6050 == 1], na.rm = TRUE),  # LEGADO (cód. educ. máx.)
      jefe_max_edu_years = {
        val <- max(P6210[P6050 == 1], na.rm = TRUE)
        if (is.finite(val)) val else 0
      },
      
      # Indicadores del jefe
      jefe_ocupado     = as.integer(any(P6050 == 1 & Oc == 1, na.rm = TRUE)),
      prestaciones_jefe= as.integer(any(P6050 == 1 &
                                  (P6510 == 1 | P6545 == 1 | P6580 == 1 |
                                   P6630s1 == 1 | P6630s2 == 1 | P6630s3 == 1 |
                                   P6630s4 == 1 | P6630s6 == 1),
                                  na.rm = TRUE)),
      horas_jefe       = ifelse(any(P6050 == 1 & Oc == 1, na.rm = TRUE),
                                dplyr::first(P6800[P6050 == 1 & Oc == 1]), 0),

      # ===== CALIDAD DEL EMPLEO (HOGAR) =======================================
      prestaciones = as.integer(
        any(P6510 == 1, na.rm = TRUE) |
        any(P6545 == 1, na.rm = TRUE) |
        any(P6580 == 1, na.rm = TRUE) |
        any(P6630s1 == 1, na.rm = TRUE) |
        any(P6630s2 == 1, na.rm = TRUE) |
        any(P6630s3 == 1, na.rm = TRUE) |
        any(P6630s4 == 1, na.rm = TRUE) |
        any(P6630s6 == 1, na.rm = TRUE)   # (prioriza versión LEGADA)
      ),
      
      prop_prest_occ = if (n_occ > 0) { 
        mean( 
          (P6510 == 1 | P6545 == 1 | P6580 == 1 | P6630s1 == 1 | P6630s2 == 1 | P6630s3 == 1 | P6630s4 == 1 | P6630s6 == 1)[Oc == 1], 
          na.rm = TRUE 
          ) 
        } else 0,

      # ===== HORAS Y TAMAÑOS (ENTRE OCUPADOS) =================================
      prom_horas_occ  = ifelse(n_occ > 0, mean(P6800[Oc == 1], na.rm = TRUE), 0), # alias LEGADO
      tam_emp_prom_occ= ifelse(n_occ > 0, mean(P6870[Oc == 1], na.rm = TRUE), 0),

      # ===== ANTIGÜEDAD / EDUCACIÓN / EDAD (ENTRE OCUPADOS) ===================
      antig_prom_occ  = ifelse(n_occ > 0, mean(P6426[Oc == 1], na.rm = TRUE), 0),
      mean_edu_occ    = ifelse(n_occ > 0, mean(edu_years[Oc == 1], na.rm = TRUE), 0),
      edad_prom_occ   = ifelse(n_occ > 0, mean(P6040[Oc == 1], na.rm = TRUE), 0),

      # ===== SEGUNDO TRABAJO ===================================================
      segundo_trabajo_hogar   = as.integer(any(P7040 == 1, na.rm = TRUE)),
      horas_segundo_trabajo_prom = ifelse(any(P7040 == 1, na.rm = TRUE),
                                          mean(P7045[P7040 == 1], na.rm = TRUE), 0),

      # ===== DESOCUPACIÓN CON INGRESOS (CLASIFICACIÓN) ========================
      n_desoc_con_ingresos   = sum(Des == 1 & (P7422 == 1 | P7472 == 1), na.rm = TRUE),
      
      desoc_con_ingresos_cat_chr = dplyr::case_when(
        n_des == 0 ~ "sin_desocupados",
        n_des > 0 & n_desoc_con_ingresos > 0 ~ "desoc_con_ingresos",
        n_des > 0 & n_desoc_con_ingresos == 0 ~ "desoc_sin_ingresos",
        TRUE ~ "sin_desocupados"
      ),

      # ===== TRABAJO INFANTIL / MAYORES (AGREGADO HOGAR) ======================
      has_child_work_no_study = any(Clase == 1 & P6040 >= 10 & P6040 <= 14 &
                                    Oc == 1 & P6240 != 3, na.rm = TRUE),
      has_child_work_study    = any(Clase == 1 & P6040 >= 10 & P6040 <= 14 &
                                    Oc == 1 & P6240 == 3, na.rm = TRUE),
      child_work_cat_chr = dplyr::case_when(
        has_child_work_no_study ~ "work_no_study",
        has_child_work_study    ~ "work_study",
        TRUE ~ "none"
      ),
      has_senior_calificado   = any(P6040 >= 65 & Oc == 1 & edu_years >= 16, na.rm = TRUE),
      has_senior_no_cal       = any(P6040 >= 65 & Oc == 1 & edu_years < 16, na.rm = TRUE),
      senior_work_cat_chr = dplyr::case_when(
        has_senior_calificado ~ "calificado",
        has_senior_no_cal     ~ "no_calificado",
        TRUE ~ "none"
      ),

      # ===== INGRESOS NO LABORALES (INDICADORES) ===============================
      ingreso_por_activos = as.integer(any(P7495 == 1 | P7500s2 == 1 | P7510s5 == 1, na.rm = TRUE)),
      ingreso_otros       = as.integer(any(P7505 == 1 | P7510s7 == 1, na.rm = TRUE)),
      ingreso_ayudas      = as.integer(any(P7510s1 == 1 | P7510s2 == 1 | P7510s3 == 1 |
                                           P7500s3 == 1 | P7510s7 == 1, na.rm = TRUE)),

      .groups = "drop"
    ) %>%
    mutate(
      # ===== FACTORES CON NIVELES EXPLÍCITOS ==================================
      desoc_con_ingresos_cat = factor(desoc_con_ingresos_cat_chr,
                                      levels = c("sin_desocupados", "desoc_con_ingresos", "desoc_sin_ingresos")),
      child_work_cat  = factor(child_work_cat_chr,
                               levels = c("none", "work_study", "work_no_study")),
      senior_work_cat = factor(senior_work_cat_chr,
                               levels = c("none", "calificado", "no_calificado"))
    ) %>%
    # ===== ORDEN FINAL DE COLUMNAS ============================================
    dplyr::select(
      # ID
      id,
      # Conteos
      n_personas, n_occ, n_des, n_ina, n_pet,
      n_pet_flex, n_no_pet_flex, n_occ_in_pet_flex,
      # Composición
      prop_occ_nper, prop_des_nper, prop_ina_nper,
      prop_no_pet_nper, prop_occ_pet, prop_occ_pet_flex,
      # Jefe del hogar
      edad_jefe, sexo_jefe, tam_emp_jefe, cotiza_pens_jefe, pos_ocup_jefe,
      antig_jefe, jefe_max_edu, jefe_max_edu_years, jefe_ocupado,
      prestaciones_jefe, horas_jefe,
      # Calidad del empleo
      prestaciones, prop_prest_occ,
      # Ocupados: horas, tamaño, antigüedad, educación y edad
      prom_horas_occ, tam_emp_prom_occ, antig_prom_occ, mean_edu_occ, edad_prom_occ,
      # Segundo trabajo
      segundo_trabajo_hogar, horas_segundo_trabajo_prom,
      # Desocupación
      n_desoc_con_ingresos, desoc_con_ingresos_cat,
      # Trabajo infantil y mayores
      child_work_cat, senior_work_cat,
      # Ingresos no laborales
      ingreso_por_activos, ingreso_otros, ingreso_ayudas
    )
}

```

```{r}
# Aplicar al TRAIN: personas -> hogares
train_agg <- agg_personas_to_hogares_plus_2(df_train_personas)
train_hogares_enriquecido <- df_train_hogares %>% left_join(train_agg, by = "id")

# Aplicar al TEST: personas -> hogares
test_agg <- agg_personas_to_hogares_plus_2(df_test_personas)
test_hogares_enriquecido  <- df_test_hogares  %>% left_join(test_agg,  by = "id")
```

```{r}
# ============================================================
# Variables base (las nuevas + básicas de hogar)
# ============================================================

vars <- c("id",
  # ---- Variables base del hogar ----
  "P5000","P5010","P5090","P5100","P5130","P5140",
  "Nper","Npersug","Depto","Lp",
  
  # ---- Conteos ----
  "n_personas","n_occ","n_des","n_ina","n_pet",
  "n_pet_flex","n_no_pet_flex","n_occ_in_pet_flex",
  
  # ---- Composición ----
  "prop_occ_nper","prop_des_nper","prop_ina_nper",
  "prop_no_pet_nper","prop_occ_pet","prop_occ_pet_flex",
  
  # ---- Jefe del hogar ----
  "edad_jefe","sexo_jefe","tam_emp_jefe","cotiza_pens_jefe",
  "pos_ocup_jefe","antig_jefe","jefe_max_edu",
  "jefe_max_edu_years","jefe_ocupado",
  "prestaciones_jefe","horas_jefe",
  
  # ---- Calidad del empleo ----
  "prestaciones","prop_prest_occ",
  
  # ---- Ocupados (promedios del hogar) ----
  "prom_horas_occ","tam_emp_prom_occ","antig_prom_occ",
  "mean_edu_occ","edad_prom_occ",
  
  # ---- Segundo trabajo ----
  "segundo_trabajo_hogar","horas_segundo_trabajo_prom",
  
  # ---- Desocupación ----
  "n_desoc_con_ingresos","desoc_con_ingresos_cat",
  
  # ---- Trabajo infantil y mayores ----
  "child_work_cat","senior_work_cat",
  
  # ---- Ingresos no laborales ----
  "ingreso_por_activos","ingreso_otros","ingreso_ayudas")

# ============================================================
# Limpieza de duplicados después de los joins
# ============================================================

train_hogares_enriquecido <- train_hogares_enriquecido %>%
  select(-ends_with(".x"), -ends_with(".y")) %>%
  distinct(id, .keep_all = TRUE)

test_hogares_enriquecido <- test_hogares_enriquecido %>%
  select(-ends_with(".x"), -ends_with(".y")) %>%
  distinct(id, .keep_all = TRUE)

# ============================================================
# Creación de interacciones y transformaciones
# ============================================================

train_hogares_enriquecido <- train_hogares_enriquecido %>%
  mutate(
    # ---- Potencias (efectos no lineales) ----
    edad_jefe2       = edad_jefe^2,
    edad_prom_occ2   = edad_prom_occ^2,

    # ---- Interacciones originales ----
    sexo_desocup     = sexo_jefe * prop_des_nper,
    edu_occ_lp       = mean_edu_occ * Lp,
    horasxedu_occ    = prom_horas_occ * mean_edu_occ,
    horasxpropocc    = prom_horas_occ * prop_occ_nper,

    # ---- Nuevas interacciones principales ----
    meanedu_x_propocc = mean_edu_occ * prop_occ_nper,
    propocc_x_lp      = prop_occ_nper * Lp,
    propocc_x_prest   = prop_occ_nper * prop_prest_occ
  )

# ---- Replicar mutaciones para test ----
test_hogares_enriquecido <- test_hogares_enriquecido %>%
  mutate(
    edad_jefe2       = edad_jefe^2,
    edad_prom_occ2   = edad_prom_occ^2,
    sexo_desocup     = sexo_jefe * prop_des_nper,
    edu_occ_lp       = mean_edu_occ * Lp,
    horasxedu_occ    = prom_horas_occ * mean_edu_occ,
    horasxpropocc    = prom_horas_occ * prop_occ_nper,
    meanedu_x_propocc = mean_edu_occ * prop_occ_nper,
    propocc_x_lp      = prop_occ_nper * Lp,
    propocc_x_prest   = prop_occ_nper * prop_prest_occ
  )

# ============================================================
# Añadir nuevas al vector de variables
# ============================================================

vars <- c(
  vars,
  "edad_jefe2","edad_prom_occ2","sexo_desocup",
  "edu_occ_lp","horasxedu_occ", "horasxpropocc",
  "meanedu_x_propocc","propocc_x_lp","propocc_x_prest"
)

# ============================================================
# Armar train/test finales para modelado
# ============================================================

train_use <- train_hogares_enriquecido %>%
  select(Pobre, all_of(vars)) %>%
  mutate(Pobre = factor(Pobre, levels = c(0,1), labels = c("no_pobre","pobre")))

test_final <- test_hogares_enriquecido %>%
  select(all_of(vars))

# ============================================================
# Definir categóricas y numéricas
# ============================================================

# Categóricas
cat_vars <- c(
  "Depto","P5090",
  "sexo_jefe","pos_ocup_jefe","cotiza_pens_jefe","jefe_max_edu",
  "child_work_cat","senior_work_cat","desoc_con_ingresos_cat"
)

# Definir numéricas como todo lo demás
num_vars <- setdiff(vars, cat_vars)

# ---- Convertir tipo adecuadamente ----
train_use[cat_vars]  <- lapply(train_use[cat_vars],  factor)
test_final[cat_vars] <- lapply(test_final[cat_vars], as.character)

# ---- Forzar conversión a numérico (maneja factors o caracteres)
for (v in c("P5100","P5130","P5140")) {
  train_use[[v]] <- as.numeric(as.character(train_use[[v]]))
  test_final[[v]] <- as.numeric(as.character(test_final[[v]]))
}

# ============================================================
# IMPUTACIÓN
# ============================================================

# 0 para numericas faltantes
for (v in num_vars) {
  train_use[[v]][is.na(train_use[[v]])] <- 0
  test_final[[v]][is.na(test_final[[v]])] <- 0
}

# cotiza_pens_jefe: imputar NA a "2" (No)
train_use$cotiza_pens_jefe[is.na(train_use$cotiza_pens_jefe)] <- "2"
test_final$cotiza_pens_jefe[is.na(test_final$cotiza_pens_jefe)] <- "2"

# ppos_ocup_jefe: crear nuevo nivel "0" y asignar a NA
levels(train_use$pos_ocup_jefe) <- c(levels(train_use$pos_ocup_jefe), "0")
levels(test_final$pos_ocup_jefe) <- c(levels(test_final$pos_ocup_jefe), "0")

train_use$pos_ocup_jefe[is.na(train_use$pos_ocup_jefe)] <- "0"
test_final$pos_ocup_jefe[is.na(test_final$pos_ocup_jefe)] <- "0"

for (v in cat_vars) {
  niveles <- union(levels(train_use[[v]]), unique(test_final[[v]]))
  train_use[[v]] <- factor(train_use[[v]], levels = niveles)
  test_final[[v]] <- factor(test_final[[v]], levels = niveles)
}

colSums(is.na(train_use))

```

```{r}
# Guardar datasets enriquecidos en "stores/"
write_csv(train_use, here::here("stores", "train_hogares_enriquecido_final.csv"))
write_csv(test_final,  here::here("stores", "test_hogares_enriquecido_final.csv"))
```





## Estadísticas Descriptivas


```{r}
#Estructura de los data sets
str(train_use)
str(test_final)
```

```{r}
# ============================================
# TRAIN only — Poor vs Non-poor
# Numéricas: mean (SE) | Categóricas: mode
# Con etiquetas bonitas en filas (stargazer texto)
# ============================================

# -------- 0) Etiquetas "bonitas" (edítalas a tu gusto) --------
var_labels <- c(
  # Numéricas
  Npersug          = "Número de personas de la unidad de gasto del hogar",
  P5130            = "Arriendo imputado/estimado",
  P5140            = "Canon de arriendo pagado",
  Lp               = "Línea de pobreza",
  edad_jefe        = "Edad del jefe del hogar",
  horas_jefe       = "Horas trabajadas por el jefe del hogar",
  n_occ            = "Número de ocupados en el hogar",
  n_des            = "Número de desocupados en el hogar",
  prom_horas_occ   = "Horas promedio trabajadas entre ocupados",
  prop_occ_nper    = "Proporción de ocupados por número de personas en el hogar",

  # Categóricas
  P5090            = "Tenencia de la vivienda",
  sexo_jefe        = "Sexo del jefe del hogar",
  cotiza_pens_jefe = "Cotiza pensión (jefe/a)",
  pos_ocup_jefe    = "Posición ocupacional del jefe del hogar",
  jefe_max_edu     = "Educación máxima del jefe del hogar"
)

# -------- 1) Selección de variables --------
num_vars <- c(
  "Npersug","P5130","P5140","Lp",
  "edad_jefe","horas_jefe","n_occ","n_des",
  "prom_horas_occ","prop_occ_nper"
)
num_vars <- num_vars[num_vars %in% names(train_use)]

cat_vars <- c("P5090","sexo_jefe","cotiza_pens_jefe","pos_ocup_jefe","jefe_max_edu")
cat_vars <- cat_vars[cat_vars %in% names(train_use)]

# -------- 2) Partir TRAIN en grupos --------
train_poor    <- subset(train_use, Pobre == "pobre")
train_nonpoor <- subset(train_use, Pobre == "no_pobre")

# -------- 3) Helpers --------
se_mean <- function(x) {
  x <- x[!is.na(x)]
  if (length(x) == 0) return(NA_real_)
  stats::sd(x) / sqrt(length(x))
}
mode_simple <- function(x) {
  x <- as.character(x)
  x <- x[!is.na(x)]
  if (length(x) == 0) return(NA_character_)
  names(sort(table(x), decreasing = TRUE))[1]
}
map_label <- function(vnames) {
  lab <- var_labels[vnames]
  lab[is.na(lab)] <- vnames[is.na(lab)]
  lab
}

# ============================
# TABLA 1 — Numéricas: mean (SE)
# ============================
if (length(num_vars) > 0) {
  # Poor
  m_poor <- sapply(train_poor[ , num_vars, drop = FALSE], function(v) mean(v, na.rm = TRUE))
  s_poor <- sapply(train_poor[ , num_vars, drop = FALSE], se_mean)
  col_poor <- ifelse(is.na(m_poor), "", sprintf("%.3f (%.3f)", m_poor, s_poor))

  # Non-poor
  m_nonp <- sapply(train_nonpoor[ , num_vars, drop = FALSE], function(v) mean(v, na.rm = TRUE))
  s_nonp <- sapply(train_nonpoor[ , num_vars, drop = FALSE], se_mean)
  col_nonp <- ifelse(is.na(m_nonp), "", sprintf("%.3f (%.3f)", m_nonp, s_nonp))

  tab_num <- data.frame(
    Variable = map_label(num_vars),
    Poor     = unname(col_poor),
    `Non-poor` = unname(col_nonp),
    check.names = FALSE,
    row.names = NULL
  )

  # Mostrar en TEXTO
  stargazer(tab_num, summary = FALSE, rownames = FALSE, type = "latex",
            title = "TRAIN — Numeric variables: mean (SE) by poverty status")
  # (Opcional) exportar a LaTeX
  # stargazer(tab_num, summary = FALSE, rownames = FALSE, type = "latex",
  #           title = "TRAIN — Numeric variables: mean (SE) by poverty status",
  #           label = "tab:train_numeric_means_se",
  #           out = "tables/train_numeric_means_se.tex")
}

# ============================
# TABLA 2 — Categóricas: mode
# ============================

# Mapas de códigos -> etiquetas
lbl_P5090 <- c(
  "1"="Propia, totalmente pagada",
  "2"="Propia, la están pagando",
  "3"="En arriendo o subarriendo",
  "4"="En usufructo",
  "5"="Posesión sin título / propiedad colectiva",
  "6"="Otra"
)

lbl_sexo <- c("1"="Hombre", "2"="Mujer")

lbl_cotiza <- c(
  "0"="No aplica / sin info",
  "1"="Sí",
  "2"="No",
  "3"="Pensionado"
)

lbl_pos <- c(
  "0"="No aplica / sin info",
  "1"="Obrero/empleado empresa particular",
  "2"="Obrero/empleado del gobierno",
  "3"="Empleado doméstico",
  "4"="Cuenta propia",
  "5"="Patrón o empleador",
  "6"="Trabajador familiar sin remuneración",
  "7"="Trabajador sin remuneración en otros hogares",
  "8"="Jornalero o peón",
  "9"="Otro"
)

lbl_edu <- c(
  "1"="Ninguno",
  "2"="Preescolar",
  "3"="Primaria",
  "4"="Secundaria (básica)",
  "5"="Media",
  "6"="Superior / universitaria",
  "7"="No sabe / no informa"
)

# Función simple para rotular (sin purrr)
label_with_map <- function(x, map) {
  y <- as.character(x)
  y[ y %in% names(map) ] <- map[ y[ y %in% names(map) ] ]
  factor(y)
}

# Crear columnas rotuladas
train_use <- train_use |>
  dplyr::mutate(
    P5090_lbl          = label_with_map(P5090, lbl_P5090),
    sexo_jefe_lbl      = label_with_map(sexo_jefe, lbl_sexo),
    cotiza_pens_lbl    = label_with_map(cotiza_pens_jefe, lbl_cotiza),
    pos_ocup_jefe_lbl  = label_with_map(pos_ocup_jefe, lbl_pos),
    jefe_max_edu_lbl   = label_with_map(jefe_max_edu, lbl_edu)
  )

# ============================
# TRAIN — Categorical variables: mode (label only)
# ============================

suppressPackageStartupMessages({
  library(stargazer)
})

# Variables categóricas rotuladas
cat_vars_lbl <- c("P5090_lbl","sexo_jefe_lbl","cotiza_pens_lbl","pos_ocup_jefe_lbl","jefe_max_edu_lbl")

# Nombres bonitos para las filas
row_labels <- c(
  P5090_lbl         = "Tenencia de la vivienda",
  sexo_jefe_lbl     = "Sexo del jefe del hogar",
  cotiza_pens_lbl   = "Cotiza pensión (jefe/a)",
  pos_ocup_jefe_lbl = "Posición ocupacional del jefe del hogar",
  jefe_max_edu_lbl  = "Educación máxima del jefe del hogar"
)

# Subconjuntos
train_poor    <- subset(train_use, Pobre == "pobre")
train_nonpoor <- subset(train_use, Pobre == "no_pobre")

# Moda (solo etiqueta)
mode_label_only <- function(x) {
  x <- as.character(x); x <- x[!is.na(x)]
  if (length(x) == 0) return("")
  tb <- table(x); names(tb)[which.max(tb)]
}

# Columnas Poor y Non-poor (solo etiquetas)
col_poor  <- sapply(cat_vars_lbl, function(v) mode_label_only(train_poor[[v]]))
col_nonp  <- sapply(cat_vars_lbl, function(v) mode_label_only(train_nonpoor[[v]]))

# Data frame final
tab_cat_labels <- data.frame(
  Variable   = unname(row_labels[cat_vars_lbl]),
  Poor       = unname(col_poor),
  `Non-poor` = unname(col_nonp),
  check.names = FALSE,
  row.names = NULL
)

# Mostrar en texto con stargazer
stargazer(tab_cat_labels, summary = FALSE, rownames = FALSE, type = "latex",
          title = "TRAIN — Categorical variables: mode (label only) by poverty status")

# (Opcional) exportar a LaTeX:
# stargazer(tab_cat_labels, summary = FALSE, rownames = FALSE, type = "latex",
#           title = "TRAIN — Categorical variables: mode (label only) by poverty status",
#           label = "tab:train_categorical_mode_labels",
#           out = "tables/train_categorical_mode_labels.tex")


```

```{r}
#Desbalanceo
ggplot(train_use, aes(x = Pobre, y = after_stat(count / sum(count)), fill = Pobre)) +
  geom_bar() +
  theme_minimal() +
  scale_y_continuous(labels = scales::percent_format(), breaks = seq(0, 1, by = 0.05)) +  
  scale_fill_manual(values = c("1" = "orange", "0"= "blue")) + 
   labs(x = "", y = "%")  
```

