---
title: "data_merge"
author: "G4"
date: "2025-10-11"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(pacman)

p_load(rio, # Import/export data.
       tidyverse, # Tidy-data.
       stargazer, # Descriptive statistics.
       gt, # Descriptive statistics.
       gtsummary,
       caret, # For predictive model assessment.
       gridExtra, # Arrange plots.
       skimr, # Summarize data.
       here, #for file searching
       readr, #for opening files
       ggplot2,
       boot,
       scales,
       car,
       dplyr,
       tidyr,
       plurrr
       )
```

```{r}
# Cargar archivos de datos

ruta1 <- here("stores", "train_hogares.csv")
df_train_hogares <- read_csv(ruta1)

ruta2 <- here("stores", "train_personas.csv")
df_train_personas <- read_csv(ruta2)

ruta3 <- here("stores", "test_personas.csv")
df_test_personas <- read_csv(ruta3)

ruta4 <- here("stores", "test_hogares.csv")
df_test_hogares <- read_csv(ruta4)

```


```{r}
# Buscador de Ids
id_objetivo <- "cf7491d7f2cc9c216bd009e7"

filas_id <- df_train_personas %>% 
  filter(id == id_objetivo)

nrow(filas_id)
as.data.frame(filas_id)

```

```{r}
# Exploramos TRAIN

# IDs de personas que SÍ están en hogares
ids_personas_en_hogares <- df_train_personas %>%
  semi_join(df_train_hogares, by = "id") %>%
  distinct(id)

ids_personas_en_hogares
nrow(ids_personas_en_hogares)

```

```{r}
# TEST
# IDs de personas que SÍ están en hogares
ids_personas_en_hogares_test <- df_test_personas %>%
  semi_join(df_test_hogares, by = "id") %>%
  distinct(id)

ids_personas_en_hogares_test
nrow(ids_personas_en_hogares_test)

```


# Create new variables at individual level

```{r}

# Function to create years of education
add_edu_years <- function(df) {
  df$edu_years <- ifelse(
    df$P6210 %in% c(1, 2, 9), 0, # None, Preschool, Unknown → 0
    ifelse(
      df$P6210 %in% c(3, 4, 5), df$P6210s1, # Primary or Secondary → as is
      ifelse(df$P6210 == 6, df$P6210s1 + 11, NA_real_) # Tertiary → add 11
    )
  )
  df
}

# Apply function to Train and Test
df_train_personas <- add_edu_years(df_train_personas)
df_test_personas  <- add_edu_years(df_test_personas)

# Function to create years of experience (Mincer-style proxy)
# exp = age - edu_years - 6
add_experience <- function(df) {
  df$exp <- df$P6040 - df$edu_years - 6
  df
}

# Apply function to Train and Test
df_train_personas <- add_experience(df_train_personas)
df_test_personas  <- add_experience(df_test_personas)

```

```{r}
# Manage NA's on labor indicators
fill_labor_nas <- function(df) {
  vars <- c("Pet", "Oc", "Des", "Ina")
  df %>%
    mutate(across(all_of(vars), ~ as.integer(replace(., is.na(.), 0L))))
}

# Apply
df_train_personas <- fill_labor_nas(df_train_personas)
df_test_personas  <- fill_labor_nas(df_test_personas)

```

# Agreggate variables to household level

```{r}

# Function to aggregate 5 household-level features from person-level data
agg_personas_to_hogares <- function(df_personas) {
  df_personas %>%
    dplyr::group_by(id) %>%
    dplyr::summarise(
      # 1) Promedio de años de educación entre ocupados (Oc==1)
      mean_edu_occ = mean(edu_years[Oc == 1], na.rm = TRUE),

      # 2) Proporción: Ocupados / número de personas en el hogar
      n_personas   = dplyr::n(),
      n_occ        = sum(Oc == 1, na.rm = TRUE),
      prop_occ_nper = n_occ / n_personas,

      # 3) Proporción: Ocupados / total # PET (PET==1)
      n_pet         = sum(Pet == 1, na.rm = TRUE),
      prop_occ_pet  = n_occ / n_pet,

      # 4) Máx. nivel educativo (P6210) del jefe (P6050==1)
      # (si hay más de un jefe marcado, toma el máximo)
      jefe_max_edu = ifelse(any(P6050 == 1), max(P6210[P6050 == 1], na.rm = TRUE), NA_real_),

      # 5) Promedio horas de trabajo por semana (P6800) entre Oc==1
      prom_horas_occ = mean(P6800[Oc == 1], na.rm = TRUE),

      .groups = "drop"
    ) %>%
    # (opcional) deja solo las 5 finales + conteos si quieres inspeccionar
    dplyr::select(id, mean_edu_occ, prop_occ_nper, prop_occ_pet, jefe_max_edu, prom_horas_occ)
}

# Aplicar al TRAIN: personas -> hogares
train_agg5 <- agg_personas_to_hogares(df_train_personas)
df_train_hogares <- df_train_hogares %>%
  dplyr::left_join(train_agg5, by = "id")

# Aplicar al TEST: personas -> hogares
test_agg5 <- agg_personas_to_hogares(df_test_personas)
df_test_hogares <- df_test_hogares %>%
  dplyr::left_join(test_agg5, by = "id")

```

```{r}
# Guardar datasets en "stores/"
write_csv(df_train_hogares, here::here("stores", "train_hogares_enriquecido.csv"))
write_csv(df_test_hogares,  here::here("stores", "test_hogares_enriquecido.csv"))
```

```{r}
# Function: agrega 14 variables a nivel hogar a partir del nivel personas
agg_personas_to_hogares_plus <- function(df_personas) {
  df_personas %>%
    group_by(id) %>%
    summarise(
      # Bases para proporciones
      n_personas     = n(),
      n_occ          = sum(Oc == 1, na.rm = TRUE),
      n_pet          = sum(Pet == 1, na.rm = TRUE),

      # 1) Promedio de años de educación entre ocupados (Oc==1)
      mean_edu_occ   = mean(edu_years[Oc == 1], na.rm = TRUE),

      # 2) Proporción: Ocupados / número de personas en el hogar
      prop_occ_nper  = n_occ / n_personas,

      # 3) Proporción: Ocupados / total # PET (PET==1)
      prop_occ_pet   = n_occ / n_pet,

      # 4) Máx nivel educativo del jefe del hogar (P6050==1)
      jefe_max_edu   = max(P6210[P6050 == 1], na.rm = TRUE),

      # 5) Años de edu promedio de los Oc==1
      edu_prom_occ   = mean(edu_years[Oc == 1], na.rm = TRUE),

      # 6) Proporción de los Des (= 1 - Prop Oc/nper)
      prop_des       = 1 - (n_occ / n_personas),

      # 7) Edad del Jefe del hogar
      edad_jefe      = first(P6040[P6050 == 1]),

      # 8) Edad promedio de los que trabajan (Oc==1)
      edad_prom_occ  = mean(P6040[Oc == 1], na.rm = TRUE),

      # 9) prestaciones = 1 si cualquiera de los ítems es "sí" (==1)
      prestaciones   = as.integer(
        any(P6510 == 1, na.rm = TRUE) |
        any(P6545 == 1, na.rm = TRUE) |
        any(P6580 == 1, na.rm = TRUE) |
        any(P6630s1 == 1, na.rm = TRUE) |
        any(P6630s2 == 1, na.rm = TRUE) |
        any(P6630s3 == 1, na.rm = TRUE) |
        any(P6630s4 == 1, na.rm = TRUE) |
        any(P6630s6 == 1, na.rm = TRUE)
      ),

      # 10) P6800 Horas usuales por semana en el trabajo principal (promedio entre Oc==1)
      horas_prom_occ = mean(P6800[Oc == 1], na.rm = TRUE),

      # 11) P6870 Tamaño empresa/negocio del Jefe
      tam_emp_jefe   = first(P6870[P6050 == 1]),

      # 12) P6870 Tamaño empresa/negocio promedio entre Oc==1
      tam_emp_prom_occ = mean(P6870[Oc == 1], na.rm = TRUE),

      # 13) P6920 ¿Cotiza a pensiones? del Jefe
      cotiza_pens_jefe = first(P6920[P6050 == 1]),

      # 14) P6430 Posición ocupacional del Jefe
      pos_ocup_jefe  = first(P6430[P6050 == 1]),
      
      # 15) Promedio horas de trabajo por semana (P6800) entre Oc==1
      prom_horas_occ = mean(P6800[Oc == 1], na.rm = TRUE),

      # 2 extras útiles que pediste arriba:
      # Sexo del jefe (P6020) y Antigüedad P6426 (jefe y promedio Oc==1)
      sexo_jefe      = first(P6020[P6050 == 1]),
      antig_jefe     = first(P6426[P6050 == 1]),
      antig_prom_occ = mean(P6426[Oc == 1], na.rm = TRUE),

      .groups = "drop"
    ) %>%
    # Deja solo las columnas finales útiles (incluye bases si quieres auditarlas)
    select(
      id,
      mean_edu_occ, prop_occ_nper, prop_occ_pet,
      jefe_max_edu, edu_prom_occ, prop_des,
      edad_jefe, edad_prom_occ, prestaciones,
      horas_prom_occ, tam_emp_jefe, tam_emp_prom_occ,
      cotiza_pens_jefe, pos_ocup_jefe,
      sexo_jefe, antig_jefe, antig_prom_occ, prom_horas_occ
    )
}

# Aplicar al TRAIN: personas -> hogares
train_agg <- agg_personas_to_hogares_plus(df_train_personas)
df_train_hogares <- df_train_hogares %>% left_join(train_agg, by = "id")

# Aplicar al TEST: personas -> hogares
test_agg <- agg_personas_to_hogares_plus(df_test_personas)
df_test_hogares  <- df_test_hogares  %>% left_join(test_agg,  by = "id")
```

```{r}
# Guardar datasets enriquecidos en "stores/"
write_csv(df_train_hogares, here::here("stores", "train_hogares_enriquecido_2.csv"))
write_csv(df_test_hogares,  here::here("stores", "test_hogares_enriquecido_2.csv"))
```
# Cinta

La fórmula determinística de lo que queremos calcular es $Pobre=I(ingreso<Lp)$. Como Lp está dado, podemos incluirla en la regresión y capturar toda su información, por lo que en parte se vuelve un juego de predecir e ingreso.

```{r}
# Pobre determinado por Ingpcug < Lp
table(df_train_hogares$Pobre, df_train_hogares$Ingpcug < df_train_hogares$Lp)

# Ingpcup se calcula con Igtotugarr?
table(round(df_train_hogares$Ingtotugarr / df_train_hogares$Npersug, 2) == round(df_train_hogares$Ingpcug, 2))

# Cuantos pobres hay? 
cat("No Pobres | Pobres")
prop.table(table(df_train_hogares$Pobre))
```

Ya que comprobamos que la pobreza se calcula según el ingreso con arriendo imputado, la variable de tenencia debe estar muy relacionada con la pobreza. 

```{r}
table(df_train_hogares$P5090, df_train_hogares$Pobre)
prop.table(table(df_train_hogares$P5090, df_train_hogares$Pobre), 1)

```


