---
title: "data_merge"
author: "G4"
date: "2025-10-11"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(pacman)

p_load(rio, # Import/export data.
       tidyverse, # Tidy-data.
       stargazer, # Descriptive statistics.
       gt, # Descriptive statistics.
       gtsummary,
       caret, # For predictive model assessment.
       gridExtra, # Arrange plots.
       skimr, # Summarize data.
       here, #for file searching
       readr, #for opening files
       ggplot2,
       boot,
       scales,
       car,
       dplyr,
       tidyr
       )
```

```{r}
ruta1 <- here("stores", "train_hogares.csv")
df_train_hogares <- read_csv(ruta1)

ruta2 <- here("stores", "train_personas.csv")
df_train_personas <- read_csv(ruta2)

ruta3 <- here("stores", "test_personas.csv")
df_test_personas <- read_csv(ruta3)

ruta4 <- here("stores", "test_hogares.csv")
df_test_hogares <- read_csv(ruta4)

```

```{r}
#    - En HOGARES debe ser único (1 fila por hogar)
#    - En PERSONAS puede repetirse (muchos individuos por hogar)
df_train_hogares %>% count(id) %>% filter(n > 1)    #debería devolver 0 filas
df_train_personas %>% count(id) %>% arrange(desc(n)) #mira la distribución personas/hogar
```

```{r}
# ¿Hay ID en personas que no existan en hogares (o viceversa)?
df_train_personas %>% anti_join(df_train_hogares, by = "id")  # debería ser 0
df_train_hogares %>% anti_join(df_train_hogares, by = "id")  # puede haber hogares sin personas?

```

```{r}
# Eliminar columnas duplicadas del dataframe combinado (excepto 'id')
duplicados <- intersect(names(df_train_personas), names(df_train_hogares))
duplicados <- setdiff(duplicados, "id")  # No eliminar 'id'

# Eliminar columnas duplicadas del dataframe combinado
df_train_hogares <- df_train_hogares %>% select(-all_of(duplicados))
df_test_hogares <- df_test_hogares %>% select(-all_of(duplicados))


# Merge de train_hogares con train_personas
df_train <- df_train_personas %>%
  left_join(df_train_hogares, by = "id")

# Merge de test_hogares con test_personas
df_test <- df_test_personas %>%
  left_join(df_test_hogares, by = "id")

# Obtener nombres de columnas comunes entre df_train y df_test
columnas_comunes <- intersect(names(df_train), names(df_test))

# Filtrar df_train para conservar solo esas columnas
df_train <- df_train %>% select(all_of(columnas_comunes))

```

```{r}
library(labelled)

# 1) Lee el diccionario (debe tener, al menos: var, etiqueta_larga)
#    Ajusta la ruta si lo guardaste en otra carpeta.

ruta5 <- here("stores", "diccionario_nombres.csv")
codebook <- read_csv(ruta5)

# (opcional) asegurar codificación en UTF-8 por si ves tildes raras
codebook <- codebook %>%
  mutate(
    etiqueta_larga = enc2utf8(etiqueta_larga)
  )

# Cambiarle los nombres a las variables y ponerles etiquetas
# Vector "var original" -> "nombre_corto"
rename_vec <- setNames(codebook$nombre_corto, codebook$var)

# Usa solo las variables que EXISTEN en df_train
rename_vec_use <- rename_vec[names(rename_vec) %in% names(df_train)]

# Avisos de columnas del codebook que no están en tu df
faltan_en_df <- setdiff(names(rename_vec), names(df_train))
if (length(faltan_en_df)) message("No están en df_train: ", paste(faltan_en_df, collapse=", "))

# Construir el mapeo en la dirección correcta para rename(): nuevo = viejo
#    Esto produce un named vector tipo c("Orden") con nombre "llave_persona"
rename_spec <- setNames(names(rename_vec_use), unname(rename_vec_use))

# Resolver problemas
if (any(duplicated(names(rename_spec)))) {
  new_names <- make.unique(names(rename_spec), sep = "_dup")
  names(rename_spec) <- new_names
  message("Se ajustaron nombres destino duplicados con sufijo _dup.")
}

# Renombrar manteniendo copia
df_train_orig <- df_train
df_train_tag <- df_train %>% rename(!!!rename_spec)

# Reaplicar etiquetas al NUEVO nombre
lab_map <- codebook %>%
  filter(var %in% names(rename_vec_use)) %>%
  mutate(nombre_dest = rename_vec_use[var]) %>%
  select(nombre_dest, etiqueta_larga)

lab_vec <- setNames(lab_map$etiqueta_larga, lab_map$nombre_dest)
keep <- intersect(names(df_train_tag), names(lab_vec))
df_train_tag <- set_variable_labels(df_train_tag, .labels = lab_vec[keep])

# Pruebas
names(df_train_tag)[1:20]
look_for(df_train_tag) %>% print(n = 60)


```

```{r}

```







Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
