---
title: "data_merge"
author: "G4"
date: "2025-10-11"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(pacman)

p_load(rio, # Import/export data.
       tidyverse, # Tidy-data.
       stargazer, # Descriptive statistics.
       gt, # Descriptive statistics.
       gtsummary,
       caret, # For predictive model assessment.
       gridExtra, # Arrange plots.
       skimr, # Summarize data.
       here, #for file searching
       readr, #for opening files
       ggplot2,
       boot,
       scales,
       car,
       dplyr,
       tidyr,
       plurrr
       )
```

```{r}
# Cargar archivos de datos

ruta1 <- here("stores", "train_hogares.csv")
df_train_hogares <- read_csv(ruta1)

ruta2 <- here("stores", "train_personas.csv")
df_train_personas <- read_csv(ruta2)

ruta3 <- here("stores", "test_personas.csv")
df_test_personas <- read_csv(ruta3)

ruta4 <- here("stores", "test_hogares.csv")
df_test_hogares <- read_csv(ruta4)

```

```{r}
# Generar conteo de personas en cada hogar
df_train_personas %>% 
  count(id, sort = TRUE) %>% 
  filter(n > 1)
```

```{r}
# Revisamos hogar con 28 personas
id_objetivo <- "cf7491d7f2cc9c216bd009e7"

filas_id <- df_train_personas %>% 
  filter(id == id_objetivo)

nrow(filas_id)
as.data.frame(filas_id)

```

```{r}
# Exploramos TRAIN

# IDs de personas que SÍ están en hogares
ids_personas_en_hogares <- df_train_personas %>%
  semi_join(df_train_hogares, by = "id") %>%
  distinct(id)

ids_personas_en_hogares
nrow(ids_personas_en_hogares)

```

```{r}
# TEST
# IDs de personas que SÍ están en hogares
ids_personas_en_hogares_test <- df_test_personas %>%
  semi_join(df_test_hogares, by = "id") %>%
  distinct(id)

ids_personas_en_hogares_test
nrow(ids_personas_en_hogares_test)

```

```{r}
str(df_test_hogares)
```

```{r}
df_test_personas %>% 
  count(id, sort = TRUE) %>% 
  filter(n > 1)
any(duplicated(df_test_personas$id))
```


```{r}
#    - En HOGARES debe ser único (1 fila por hogar)
#    - En PERSONAS puede repetirse (muchos individuos por hogar)
df_train_hogares %>% count(id) %>% filter(n > 1)    #debería devolver 0 filas
df_train_personas %>% count(id) %>% arrange(desc(n)) #mira la distribución personas/hogar
```

```{r}
# ¿Hay ID en personas que no existan en hogares (o viceversa)?
df_train_personas %>% anti_join(df_train_hogares, by = "id")  # debería ser 0
df_train_hogares %>% anti_join(df_train_hogares, by = "id")  # puede haber hogares sin personas?

```


```{r}
library(labelled)

# 1) Lee el diccionario (debe tener, al menos: var, etiqueta_larga)
#    Ajusta la ruta si lo guardaste en otra carpeta.

ruta5 <- here("stores", "diccionario_nombres.csv")
codebook <- read_csv(ruta5)

# (opcional) asegurar codificación en UTF-8 por si ves tildes raras
codebook <- codebook %>%
  mutate(
    etiqueta_larga = enc2utf8(etiqueta_larga)
  )

# Cambiarle los nombres a las variables y ponerles etiquetas
# Vector "var original" -> "nombre_corto"
rename_vec <- setNames(codebook$nombre_corto, codebook$var)

# Usa solo las variables que EXISTEN en df_train
rename_vec_use <- rename_vec[names(rename_vec) %in% names(df_train)]

# Avisos de columnas del codebook que no están en tu df
faltan_en_df <- setdiff(names(rename_vec), names(df_train))
if (length(faltan_en_df)) message("No están en df_train: ", paste(faltan_en_df, collapse=", "))

# Construir el mapeo en la dirección correcta para rename(): nuevo = viejo
#    Esto produce un named vector tipo c("Orden") con nombre "llave_persona"
rename_spec <- setNames(names(rename_vec_use), unname(rename_vec_use))

# Resolver problemas
if (any(duplicated(names(rename_spec)))) {
  new_names <- make.unique(names(rename_spec), sep = "_dup")
  names(rename_spec) <- new_names
  message("Se ajustaron nombres destino duplicados con sufijo _dup.")
}

# Renombrar manteniendo copia
df_train_orig <- df_train
df_train_tag <- df_train %>% rename(!!!rename_spec)

# Reaplicar etiquetas al NUEVO nombre
lab_map <- codebook %>%
  filter(var %in% names(rename_vec_use)) %>%
  mutate(nombre_dest = rename_vec_use[var]) %>%
  select(nombre_dest, etiqueta_larga)

lab_vec <- setNames(lab_map$etiqueta_larga, lab_map$nombre_dest)
keep <- intersect(names(df_train_tag), names(lab_vec))
df_train_tag <- set_variable_labels(df_train_tag, .labels = lab_vec[keep])

# Pruebas
names(df_train_tag)[1:20]
look_for(df_train_tag) %>% print(n = 60)


```

# Create new variables at individual level

```{r}

# Function to create years of education
add_edu_years <- function(df) {
  df$edu_years <- ifelse(
    df$P6210 %in% c(1, 2, 9), 0, # None, Preschool, Unknown → 0
    ifelse(
      df$P6210 %in% c(3, 4, 5), df$P6210s1, # Primary or Secondary → as is
      ifelse(df$P6210 == 6, df$P6210s1 + 11, NA_real_) # Tertiary → add 11
    )
  )
  df
}

# Apply function to Train and Test
df_train_personas <- add_edu_years(df_train_personas)
df_test_personas  <- add_edu_years(df_test_personas)

# Function to create years of experience (Mincer-style proxy)
# exp = age - edu_years - 6
add_experience <- function(df) {
  df$exp <- df$P6040 - df$edu_years - 6
  df
}

# Apply function to Train and Test
df_train_personas <- add_experience(df_train_personas)
df_test_personas  <- add_experience(df_test_personas)

```

```{r}
# Manage NA's on labor indicators
fill_labor_nas <- function(df) {
  vars <- c("Pet", "Oc", "Des", "Ina")
  df %>%
    mutate(across(all_of(vars), ~ as.integer(replace(., is.na(.), 0L))))
}

# Apply
df_train_personas <- fill_labor_nas(df_train_personas)
df_test_personas  <- fill_labor_nas(df_test_personas)

```

# Agreggate variables to household level

```{r}

# Function to aggregate 5 household-level features from person-level data
agg_personas_to_hogares <- function(df_personas) {
  df_personas %>%
    dplyr::group_by(id) %>%
    dplyr::summarise(
      # 1) Promedio de años de educación entre ocupados (Oc==1)
      mean_edu_occ = mean(edu_years[Oc == 1], na.rm = TRUE),

      # 2) Proporción: Ocupados / número de personas en el hogar
      n_personas   = dplyr::n(),
      n_occ        = sum(Oc == 1, na.rm = TRUE),
      prop_occ_nper = n_occ / n_personas,

      # 3) Proporción: Ocupados / total # PET (PET==1)
      n_pet         = sum(Pet == 1, na.rm = TRUE),
      prop_occ_pet  = n_occ / n_pet,

      # 4) Máx. nivel educativo (P6210) del jefe (P6050==1)
      # (si hay más de un jefe marcado, toma el máximo)
      jefe_max_edu = ifelse(any(P6050 == 1), max(P6210[P6050 == 1], na.rm = TRUE), NA_real_),

      # 5) Promedio horas de trabajo por semana (P6800) entre Oc==1
      prom_horas_occ = mean(P6800[Oc == 1], na.rm = TRUE),

      .groups = "drop"
    ) %>%
    # (opcional) deja solo las 5 finales + conteos si quieres inspeccionar
    dplyr::select(id, mean_edu_occ, prop_occ_nper, prop_occ_pet, jefe_max_edu, prom_horas_occ)
}

# Aplicar al TRAIN: personas -> hogares
train_agg5 <- agg_personas_to_hogares(df_train_personas)
df_train_hogares <- df_train_hogares %>%
  dplyr::left_join(train_agg5, by = "id")

# Aplicar al TEST: personas -> hogares
test_agg5 <- agg_personas_to_hogares(df_test_personas)
df_test_hogares <- df_test_hogares %>%
  dplyr::left_join(test_agg5, by = "id")

```

```{r}

```