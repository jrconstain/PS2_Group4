---
title: "data_merge"
author: "G4"
date: "2025-10-11"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(pacman)

p_load(rio, # Import/export data.
       tidyverse, # Tidy-data.
       stargazer, # Descriptive statistics.
       gt, # Descriptive statistics.
       gtsummary,
       caret, # For predictive model assessment.
       gridExtra, # Arrange plots.
       skimr, # Summarize data.
       here, #for file searching
       readr, #for opening files
       ggplot2,
       boot,
       scales,
       car,
       dplyr,
       tidyr
       )
```

```{r}
ruta1 <- here("stores", "train_hogares.csv")
df_train_hogares <- read_csv(ruta1)

ruta2 <- here("stores", "train_personas.csv")
df_train_personas <- read_csv(ruta2)

ruta3 <- here("stores", "test_personas.csv")
df_test_personas <- read_csv(ruta3)

ruta4 <- here("stores", "test_hogares.csv")
df_test_hogares <- read_csv(ruta4)

```

```{r}
#    - En HOGARES debe ser único (1 fila por hogar)
#    - En PERSONAS puede repetirse (muchos individuos por hogar)
df_train_hogares %>% count(id) %>% filter(n > 1)    #debería devolver 0 filas
df_train_personas %>% count(id) %>% arrange(desc(n)) #mira la distribución personas/hogar
```

```{r}
# ¿Hay ID en personas que no existan en hogares (o viceversa)?
df_train_personas %>% anti_join(df_train_hogares, by = "id")  # debería ser 0
df_train_hogares %>% anti_join(df_train_hogares, by = "id")  # puede haber hogares sin personas?

```

```{r}



# Merge de train_hogares con train_personas
df_train <- df_train_personas %>%
  left_join(df_train_hogares, by = "id")

# Merge de test_hogares con test_personas
df_test <- df_test_personas %>%
  left_join(df_test_hogares, by = "id")

# Verificar estructura de los nuevos dataframes
glimpse(df_train)
glimpse(df_test)


```





Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
